필요한 것은 2시, 6시, 0시의 극</br>
따라서 만약 처음 2시와 6시의 극이 같으면 인덱스를 옮겨주고.. 하는 식으로 구현하려고 시도</br>
-> 실패

2와 6 같은 시간은 고정해놓고 톱니를 그냥 옮겨버리자!</br>
만약 시계 방향으로 이동해야 하면
```
if(d[j] == 1) {
	tmp = arr[j][7];
	for(int t = 7; t>0; t--)
		arr[j][t] = arr[j][t-1];
	arr[j][0] = tmp;
}
```

반시계 방향으로 이동해야 하면
```
else if(d[j] == -1) {
	tmp = arr[j][0];
	for(int t = 0; t<7; t++)
		arr[j][t] = arr[j][t+1];
	arr[j][7] = tmp;
}
```
이렇게 이동하게 함

이때 주의할 점은 처음에 if와 else로만 구분했는데,</br>
d는 1와 -1 뿐만 아니라 0일 수도 있다 (이동 안한 경우)</br>
0일 때는 이동하면 안됨</br>
따라서 `if(d[j] == 1)` 와 `if(d[j] == -1)` 로 나눠줘야 한다

그리고 처음 마주하는 면의 극이 같으면 그대로 유지하고 아니면 회전하는데</br>
이때 그때그때 회전시켜버리면 안됨</br>
처음 부분에서 마주하는 부분의 극을 비교한 후 한 타임 끝나고 한 번에 바꾸니까!</br>
따라서 회전해야한다면 d배열에 1이나 -1을 넣어서 배열 갱신

너무 복잡하게 구현하려고 했던 것 같다..</br>
구현 문제는 실수하지 않고 차근차근 풀려고 하기
