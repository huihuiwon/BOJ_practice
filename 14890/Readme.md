기본적인 아이디어는 for문을 다 도는 구현</br>
이때 만약 현재 보고 있는 지점에서 l만큼 길이가 같고, 그 사이에 경사가 없으면 경사를 놓는다고 생각

```
int basic = map[i][j];
for(int k=j; k>j-m; k--) {
	if(k<0 || map[i][k] != basic || chk[i][k]) {
		flag = false;
		break;
	}
	if(k>=0) chk[i][k]=true;
}
```

이런 식으로 표현</br>
(위의 코드는 현재 높이가 이전 높이보다 낮은 경우)

처음에 경사를 놓았다는 체크를 하지 않았다 (체크안해도 된다고 생각)</br>
하지만 만약 3 2 3 이런 식으로 되어 있다면, 2에 경사가 두 번 놓이게 됨</br>
이런 경우를 제외시켜주기 위해 체크 배열을 선언

그리고 `if(j-m < 0)` 이라 선언했었는데, j-m 이 아니라 j-m+1 이 되어야 한다</br>
만약 현재 인덱스가 1이고, l의 길이가 2라면, 경사가 놓이는 인덱스는 0과 1</br>
하지만 그냥 j-m 을 해버리면 -1이 된다

그리고 경사 구간의 높이가 모두 같은지 확인하기 위해 k와 k+1 이런 식으로 비교했는데</br>
만약 l이 1이라면?</br>
map[i][j] 와 map[i][j+1] 을 비교하면 안된다

따라서 basic 변수를 선언하고, 경사의 길이만큼 basic 변수와 동일한지 비교
</br></br>

***
1. 인덱스 오류가 많았음
2. 디버깅 위한 코드를 함께 올려서 오답
