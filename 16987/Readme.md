처음에 N개의 수로 만들 수 있는 순열을 만들어놓고,</br>
그 순서대로 계란을 깨면 된다고 생각</br>

하지만 2번 과정에서 깨는 계란은 마음대로 고를 수 있으나</br>
3번 과정에서는 원래 들고 있었던 계란의 옆에 있는 계란을 손에 들어야 한다

s배열과 w배열을 선언</br>
s배열은 내구도, w배열은 무게

order 함수를 만들어서 만약 현재 보고 있는 `s[L]<=0` 이라면,</br>
즉 현재 보고 있는 계란의 내구도가 0 이하라면 깨진 것이므로 문제 조건대로 다른 계란을 치지 않고 넘어간다</br>
여기서는 `order(L+1)`로 구현

아니라면 다른 계란 중에 깰 계란을 선택해야하는데</br>
이는 브루트 포스로 모든 경우를 생각해줘야 한다

```
else {
	boolean chk = false;
	for(int i=0; i<n; i++) {
		if(L==i || s[i] <= 0) continue;
		s[i]-=w[L];
		s[L]-=w[i];
		chk = true;
		order(L+1);
		s[i]+=w[L];
		s[L]+=w[i];
	}
	if(!chk) order(L+1);
}
```

코드는 위와 같다</br>
`L==i` 라는 뜻은 현재 들고 있는 계란과 똑같은 계란을 선택하려는 것이니 패스</br>
boolean chk 변수를 사용하는 이유는 더이상 꺨 계란이 없을 경우 치지 않고 넘어간다는 조건을 위함</br>
만약 마지막까지 chk 변수가 false라면 아무 계란도 치지 않았다는 뜻이므로,</br>
다음 단계로 넘어가기 위해 order(L+1)

모든 과정이 끝난 후,</br>
즉 제일 오른쪽 계란을 선택한 경우

```
if(L==n) {
	int cnt=0;
	for(int i=0; i<n; i++)
		if(s[i] <= 0) cnt++;

	ans = Math.max(cnt, ans);
	return;
}
```

0보다 작은 s[i] 수를 세어서 cnt와 ans를 구한다
