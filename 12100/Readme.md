백트래킹을 이용해서 순열을 일단 선택</br>
N개 중에 M개를 선택해야하는데 이때 N보다 M이 크다</br>
하지만 별 상관없이 arr[M], chk[M+1]로 선언 후 기존 순열 구하는 방법과 동일하게 해주면 됨

순열을 선택했다는 뜻은 5번 어떻게 움직일 지 결정했다는 뜻</br>
그 후부터는 큐와 배열을 모두 이용해줬다

큐에 순서대로 `map[i][j]!=0` 이면 그 값을 넣는데, 이때 인덱스는 같이 넣을 필요 없음</br>
어차피 0이나 size-1부터 순서대로 넣을 것이니까!

그 후 만약 `q.peek()`와 `q.poll()`이 같다면, 그 값에 *2 한 값을 넣고 아니면 그냥 넣는다</br>
그 후 인덱스 +1 을 해줘야 함</br>
이때 지나온 배열값은 0으로 바꿔줘야 같은 값을 계속 더하지 않는다


***
다만 시간과 메모리 사용이 너무 많다</br>
DFS와 재귀를 이용해서 풀 수도 있음

움직이는 함수를 4개 따로 만들어주고, 새로운 배열(이하 new_map)을 하나 생성</br>
그 후 map을 보면서 값을 넣고 new_map을 리턴해준 후 다음 순서 차례에서 그 new_map을 쓰면 됨</br>
그러면 처음에 new_map을 만들고 그 안에 map 값을 다 넣고 다시 0으로 바꿔주고.. 이럴 필요가 없다

실수했던 부분은 오른쪽으로 밀 때, 값을 큐에 넣을 때 size-1부터 넣어야 하는데 0부터 넣은 점
